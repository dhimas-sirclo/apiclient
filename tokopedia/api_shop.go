/*
Tokopedia API

Tokopedia API

API version: 1.0
Contact: dev@sirclo.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tokopedia

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ShopAPI interface {

	/*
	CreateShowcase Method for CreateShowcase

	This endpoint used to create new showcase based on shop_id and fs_id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ShopAPICreateShowcaseRequest
	*/
	CreateShowcase(ctx context.Context, fsId int64) ShopAPICreateShowcaseRequest

	// CreateShowcaseExecute executes the request
	//  @return CreateShowcase200Response
	CreateShowcaseExecute(r ShopAPICreateShowcaseRequest) (*CreateShowcase200Response, *http.Response, error)

	// CreateShowcaseExecuteWithRetry executes the request with retry
	//  @return CreateShowcase200Response
	CreateShowcaseExecuteWithRetry(r ShopAPICreateShowcaseRequest, maxRetry, maxDelayMs int) (*CreateShowcase200Response, *http.Response, error)

	/*
	DeleteShowcase Method for DeleteShowcase

	This endpoint used to delete existing showcase based on showcase_id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ShopAPIDeleteShowcaseRequest
	*/
	DeleteShowcase(ctx context.Context, fsId int64) ShopAPIDeleteShowcaseRequest

	// DeleteShowcaseExecute executes the request
	//  @return DeleteShowcase200Response
	DeleteShowcaseExecute(r ShopAPIDeleteShowcaseRequest) (*DeleteShowcase200Response, *http.Response, error)

	// DeleteShowcaseExecuteWithRetry executes the request with retry
	//  @return DeleteShowcase200Response
	DeleteShowcaseExecuteWithRetry(r ShopAPIDeleteShowcaseRequest, maxRetry, maxDelayMs int) (*DeleteShowcase200Response, *http.Response, error)

	/*
	GetShopInfo Method for GetShopInfo

	This endpoint returns shop information from shop_id that associated with fs_id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ShopAPIGetShopInfoRequest
	*/
	GetShopInfo(ctx context.Context, fsId int64) ShopAPIGetShopInfoRequest

	// GetShopInfoExecute executes the request
	//  @return GetShopInfo200Response
	GetShopInfoExecute(r ShopAPIGetShopInfoRequest) (*GetShopInfo200Response, *http.Response, error)

	// GetShopInfoExecuteWithRetry executes the request with retry
	//  @return GetShopInfo200Response
	GetShopInfoExecuteWithRetry(r ShopAPIGetShopInfoRequest, maxRetry, maxDelayMs int) (*GetShopInfo200Response, *http.Response, error)

	/*
	GetShowcase Method for GetShowcase

	This endpoint used to get existing showcase based on shopID and FSID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ShopAPIGetShowcaseRequest
	*/
	GetShowcase(ctx context.Context, fsId int64) ShopAPIGetShowcaseRequest

	// GetShowcaseExecute executes the request
	//  @return GetShowcase200Response
	GetShowcaseExecute(r ShopAPIGetShowcaseRequest) (*GetShowcase200Response, *http.Response, error)

	// GetShowcaseExecuteWithRetry executes the request with retry
	//  @return GetShowcase200Response
	GetShowcaseExecuteWithRetry(r ShopAPIGetShowcaseRequest, maxRetry, maxDelayMs int) (*GetShowcase200Response, *http.Response, error)

	/*
	GetShowcaseAllEtalase Method for GetShowcaseAllEtalase

	This endpoint retrieves a list of all etalase owned by a shop_id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ShopAPIGetShowcaseAllEtalaseRequest
	*/
	GetShowcaseAllEtalase(ctx context.Context, fsId int64) ShopAPIGetShowcaseAllEtalaseRequest

	// GetShowcaseAllEtalaseExecute executes the request
	//  @return GetShowcaseAllEtalase200Response
	GetShowcaseAllEtalaseExecute(r ShopAPIGetShowcaseAllEtalaseRequest) (*GetShowcaseAllEtalase200Response, *http.Response, error)

	// GetShowcaseAllEtalaseExecuteWithRetry executes the request with retry
	//  @return GetShowcaseAllEtalase200Response
	GetShowcaseAllEtalaseExecuteWithRetry(r ShopAPIGetShowcaseAllEtalaseRequest, maxRetry, maxDelayMs int) (*GetShowcaseAllEtalase200Response, *http.Response, error)

	/*
	UpdateShopStatus Method for UpdateShopStatus

	This endpoint to update shop status into open or close.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ShopAPIUpdateShopStatusRequest
	*/
	UpdateShopStatus(ctx context.Context, fsId int64) ShopAPIUpdateShopStatusRequest

	// UpdateShopStatusExecute executes the request
	//  @return UpdateShopStatusDefaultResponse
	UpdateShopStatusExecute(r ShopAPIUpdateShopStatusRequest) (*UpdateShopStatusDefaultResponse, *http.Response, error)

	// UpdateShopStatusExecuteWithRetry executes the request with retry
	//  @return UpdateShopStatusDefaultResponse
	UpdateShopStatusExecuteWithRetry(r ShopAPIUpdateShopStatusRequest, maxRetry, maxDelayMs int) (*UpdateShopStatusDefaultResponse, *http.Response, error)

	/*
	UpdateShowcase Method for UpdateShowcase

	This endpoint used to update existing showcase based on showcase_id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ShopAPIUpdateShowcaseRequest
	*/
	UpdateShowcase(ctx context.Context, fsId int64) ShopAPIUpdateShowcaseRequest

	// UpdateShowcaseExecute executes the request
	//  @return DeleteShowcase200Response
	UpdateShowcaseExecute(r ShopAPIUpdateShowcaseRequest) (*DeleteShowcase200Response, *http.Response, error)

	// UpdateShowcaseExecuteWithRetry executes the request with retry
	//  @return DeleteShowcase200Response
	UpdateShowcaseExecuteWithRetry(r ShopAPIUpdateShowcaseRequest, maxRetry, maxDelayMs int) (*DeleteShowcase200Response, *http.Response, error)
}

// ShopAPIService ShopAPI service
type ShopAPIService service

type ShopAPICreateShowcaseRequest struct {
	ctx context.Context
	ApiService ShopAPI
	fsId int64
	shopId *int64
	createShowcaseRequest *CreateShowcaseRequest
}

// Shop unique identifier
func (r ShopAPICreateShowcaseRequest) ShopId(shopId int64) ShopAPICreateShowcaseRequest {
	r.shopId = &shopId
	return r
}

func (r ShopAPICreateShowcaseRequest) CreateShowcaseRequest(createShowcaseRequest CreateShowcaseRequest) ShopAPICreateShowcaseRequest {
	r.createShowcaseRequest = &createShowcaseRequest
	return r
}

func (r ShopAPICreateShowcaseRequest) Execute() (*CreateShowcase200Response, *http.Response, error) {
	return r.ApiService.CreateShowcaseExecute(r)
}

func (r ShopAPICreateShowcaseRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*CreateShowcase200Response, *http.Response, error) {
	return r.ApiService.CreateShowcaseExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
CreateShowcase Method for CreateShowcase

This endpoint used to create new showcase based on shop_id and fs_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ShopAPICreateShowcaseRequest
*/
func (a *ShopAPIService) CreateShowcase(ctx context.Context, fsId int64) ShopAPICreateShowcaseRequest {
	return ShopAPICreateShowcaseRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return CreateShowcase200Response
func (a *ShopAPIService) CreateShowcaseExecute(r ShopAPICreateShowcaseRequest) (*CreateShowcase200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateShowcase200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.CreateShowcase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/showcase/fs/{fs_id}/create"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.createShowcaseRequest == nil {
		return localVarReturnValue, nil, reportError("createShowcaseRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createShowcaseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return CreateShowcase200Response
func (a *ShopAPIService) CreateShowcaseExecuteWithRetry(r ShopAPICreateShowcaseRequest, maxRetry, maxDelayMs int) (*CreateShowcase200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateShowcase200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.CreateShowcase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/showcase/fs/{fs_id}/create"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.createShowcaseRequest == nil {
		return localVarReturnValue, nil, reportError("createShowcaseRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createShowcaseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopAPIDeleteShowcaseRequest struct {
	ctx context.Context
	ApiService ShopAPI
	fsId int64
	shopId *int64
	deleteShowcaseRequest *DeleteShowcaseRequest
}

// Shop unique identifier
func (r ShopAPIDeleteShowcaseRequest) ShopId(shopId int64) ShopAPIDeleteShowcaseRequest {
	r.shopId = &shopId
	return r
}

func (r ShopAPIDeleteShowcaseRequest) DeleteShowcaseRequest(deleteShowcaseRequest DeleteShowcaseRequest) ShopAPIDeleteShowcaseRequest {
	r.deleteShowcaseRequest = &deleteShowcaseRequest
	return r
}

func (r ShopAPIDeleteShowcaseRequest) Execute() (*DeleteShowcase200Response, *http.Response, error) {
	return r.ApiService.DeleteShowcaseExecute(r)
}

func (r ShopAPIDeleteShowcaseRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*DeleteShowcase200Response, *http.Response, error) {
	return r.ApiService.DeleteShowcaseExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
DeleteShowcase Method for DeleteShowcase

This endpoint used to delete existing showcase based on showcase_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ShopAPIDeleteShowcaseRequest
*/
func (a *ShopAPIService) DeleteShowcase(ctx context.Context, fsId int64) ShopAPIDeleteShowcaseRequest {
	return ShopAPIDeleteShowcaseRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return DeleteShowcase200Response
func (a *ShopAPIService) DeleteShowcaseExecute(r ShopAPIDeleteShowcaseRequest) (*DeleteShowcase200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteShowcase200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.DeleteShowcase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/showcase/fs/{fs_id}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.deleteShowcaseRequest == nil {
		return localVarReturnValue, nil, reportError("deleteShowcaseRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteShowcaseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return DeleteShowcase200Response
func (a *ShopAPIService) DeleteShowcaseExecuteWithRetry(r ShopAPIDeleteShowcaseRequest, maxRetry, maxDelayMs int) (*DeleteShowcase200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteShowcase200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.DeleteShowcase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/showcase/fs/{fs_id}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.deleteShowcaseRequest == nil {
		return localVarReturnValue, nil, reportError("deleteShowcaseRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteShowcaseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopAPIGetShopInfoRequest struct {
	ctx context.Context
	ApiService ShopAPI
	fsId int64
	shopId *int64
	page *int64
	perPage *int64
}

// Shop unique identifier
func (r ShopAPIGetShopInfoRequest) ShopId(shopId int64) ShopAPIGetShopInfoRequest {
	r.shopId = &shopId
	return r
}

// Determine which page the order list should start. The minimal value is 1
func (r ShopAPIGetShopInfoRequest) Page(page int64) ShopAPIGetShopInfoRequest {
	r.page = &page
	return r
}

// Determine how many orders will be shown per page
func (r ShopAPIGetShopInfoRequest) PerPage(perPage int64) ShopAPIGetShopInfoRequest {
	r.perPage = &perPage
	return r
}

func (r ShopAPIGetShopInfoRequest) Execute() (*GetShopInfo200Response, *http.Response, error) {
	return r.ApiService.GetShopInfoExecute(r)
}

func (r ShopAPIGetShopInfoRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*GetShopInfo200Response, *http.Response, error) {
	return r.ApiService.GetShopInfoExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetShopInfo Method for GetShopInfo

This endpoint returns shop information from shop_id that associated with fs_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ShopAPIGetShopInfoRequest
*/
func (a *ShopAPIService) GetShopInfo(ctx context.Context, fsId int64) ShopAPIGetShopInfoRequest {
	return ShopAPIGetShopInfoRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return GetShopInfo200Response
func (a *ShopAPIService) GetShopInfoExecute(r ShopAPIGetShopInfoRequest) (*GetShopInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetShopInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.GetShopInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/shop/fs/{fs_id}/shop-info"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.shopId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetShopInfoDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return GetShopInfo200Response
func (a *ShopAPIService) GetShopInfoExecuteWithRetry(r ShopAPIGetShopInfoRequest, maxRetry, maxDelayMs int) (*GetShopInfo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetShopInfo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.GetShopInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/shop/fs/{fs_id}/shop-info"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.shopId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetShopInfoDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopAPIGetShowcaseRequest struct {
	ctx context.Context
	ApiService ShopAPI
	fsId int64
	shopId *int64
	page *int64
	pageCount *int64
	hideZero *bool
	display *string
}

// Shop unique identifier
func (r ShopAPIGetShowcaseRequest) ShopId(shopId int64) ShopAPIGetShowcaseRequest {
	r.shopId = &shopId
	return r
}

// USelect which page to show, default value: 1 
func (r ShopAPIGetShowcaseRequest) Page(page int64) ShopAPIGetShowcaseRequest {
	r.page = &page
	return r
}

// Showcase contained in each page, default value: 10 
func (r ShopAPIGetShowcaseRequest) PageCount(pageCount int64) ShopAPIGetShowcaseRequest {
	r.pageCount = &pageCount
	return r
}

// Hide showcase if product equal to zero, default value: false 
func (r ShopAPIGetShowcaseRequest) HideZero(hideZero bool) ShopAPIGetShowcaseRequest {
	r.hideZero = &hideZero
	return r
}

// To determine which showcase that you want to see. Accepted value: showcase to get user showcases only, group to get group showcases only, all to get both, default value: all 
func (r ShopAPIGetShowcaseRequest) Display(display string) ShopAPIGetShowcaseRequest {
	r.display = &display
	return r
}

func (r ShopAPIGetShowcaseRequest) Execute() (*GetShowcase200Response, *http.Response, error) {
	return r.ApiService.GetShowcaseExecute(r)
}

func (r ShopAPIGetShowcaseRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*GetShowcase200Response, *http.Response, error) {
	return r.ApiService.GetShowcaseExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetShowcase Method for GetShowcase

This endpoint used to get existing showcase based on shopID and FSID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ShopAPIGetShowcaseRequest
*/
func (a *ShopAPIService) GetShowcase(ctx context.Context, fsId int64) ShopAPIGetShowcaseRequest {
	return ShopAPIGetShowcaseRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return GetShowcase200Response
func (a *ShopAPIService) GetShowcaseExecute(r ShopAPIGetShowcaseRequest) (*GetShowcase200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetShowcase200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.GetShowcase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/showcase/fs/{fs_id}/get"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_count", r.pageCount, "")
	}
	if r.hideZero != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hide_zero", r.hideZero, "")
	}
	if r.display != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "display", r.display, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return GetShowcase200Response
func (a *ShopAPIService) GetShowcaseExecuteWithRetry(r ShopAPIGetShowcaseRequest, maxRetry, maxDelayMs int) (*GetShowcase200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetShowcase200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.GetShowcase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/showcase/fs/{fs_id}/get"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.pageCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_count", r.pageCount, "")
	}
	if r.hideZero != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hide_zero", r.hideZero, "")
	}
	if r.display != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "display", r.display, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopAPIGetShowcaseAllEtalaseRequest struct {
	ctx context.Context
	ApiService ShopAPI
	fsId int64
	shopId *int64
}

// Shop unique identifier
func (r ShopAPIGetShowcaseAllEtalaseRequest) ShopId(shopId int64) ShopAPIGetShowcaseAllEtalaseRequest {
	r.shopId = &shopId
	return r
}

func (r ShopAPIGetShowcaseAllEtalaseRequest) Execute() (*GetShowcaseAllEtalase200Response, *http.Response, error) {
	return r.ApiService.GetShowcaseAllEtalaseExecute(r)
}

func (r ShopAPIGetShowcaseAllEtalaseRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*GetShowcaseAllEtalase200Response, *http.Response, error) {
	return r.ApiService.GetShowcaseAllEtalaseExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetShowcaseAllEtalase Method for GetShowcaseAllEtalase

This endpoint retrieves a list of all etalase owned by a shop_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ShopAPIGetShowcaseAllEtalaseRequest
*/
func (a *ShopAPIService) GetShowcaseAllEtalase(ctx context.Context, fsId int64) ShopAPIGetShowcaseAllEtalaseRequest {
	return ShopAPIGetShowcaseAllEtalaseRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return GetShowcaseAllEtalase200Response
func (a *ShopAPIService) GetShowcaseAllEtalaseExecute(r ShopAPIGetShowcaseAllEtalaseRequest) (*GetShowcaseAllEtalase200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetShowcaseAllEtalase200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.GetShowcaseAllEtalase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/product/etalase"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return GetShowcaseAllEtalase200Response
func (a *ShopAPIService) GetShowcaseAllEtalaseExecuteWithRetry(r ShopAPIGetShowcaseAllEtalaseRequest, maxRetry, maxDelayMs int) (*GetShowcaseAllEtalase200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetShowcaseAllEtalase200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.GetShowcaseAllEtalase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/product/etalase"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopAPIUpdateShopStatusRequest struct {
	ctx context.Context
	ApiService ShopAPI
	fsId int64
	updateShopStatusRequest *UpdateShopStatusRequest
}

func (r ShopAPIUpdateShopStatusRequest) UpdateShopStatusRequest(updateShopStatusRequest UpdateShopStatusRequest) ShopAPIUpdateShopStatusRequest {
	r.updateShopStatusRequest = &updateShopStatusRequest
	return r
}

func (r ShopAPIUpdateShopStatusRequest) Execute() (*UpdateShopStatusDefaultResponse, *http.Response, error) {
	return r.ApiService.UpdateShopStatusExecute(r)
}

func (r ShopAPIUpdateShopStatusRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*UpdateShopStatusDefaultResponse, *http.Response, error) {
	return r.ApiService.UpdateShopStatusExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
UpdateShopStatus Method for UpdateShopStatus

This endpoint to update shop status into open or close.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ShopAPIUpdateShopStatusRequest
*/
func (a *ShopAPIService) UpdateShopStatus(ctx context.Context, fsId int64) ShopAPIUpdateShopStatusRequest {
	return ShopAPIUpdateShopStatusRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return UpdateShopStatusDefaultResponse
func (a *ShopAPIService) UpdateShopStatusExecute(r ShopAPIUpdateShopStatusRequest) (*UpdateShopStatusDefaultResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateShopStatusDefaultResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.UpdateShopStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/shop/fs/{fs_id}/shop-status"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateShopStatusRequest == nil {
		return localVarReturnValue, nil, reportError("updateShopStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateShopStatusRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v UpdateShopStatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return UpdateShopStatusDefaultResponse
func (a *ShopAPIService) UpdateShopStatusExecuteWithRetry(r ShopAPIUpdateShopStatusRequest, maxRetry, maxDelayMs int) (*UpdateShopStatusDefaultResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateShopStatusDefaultResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.UpdateShopStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/shop/fs/{fs_id}/shop-status"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateShopStatusRequest == nil {
		return localVarReturnValue, nil, reportError("updateShopStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateShopStatusRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v UpdateShopStatusDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopAPIUpdateShowcaseRequest struct {
	ctx context.Context
	ApiService ShopAPI
	fsId int64
	shopId *int64
	updateShowcaseRequest *UpdateShowcaseRequest
}

// Shop unique identifier
func (r ShopAPIUpdateShowcaseRequest) ShopId(shopId int64) ShopAPIUpdateShowcaseRequest {
	r.shopId = &shopId
	return r
}

func (r ShopAPIUpdateShowcaseRequest) UpdateShowcaseRequest(updateShowcaseRequest UpdateShowcaseRequest) ShopAPIUpdateShowcaseRequest {
	r.updateShowcaseRequest = &updateShowcaseRequest
	return r
}

func (r ShopAPIUpdateShowcaseRequest) Execute() (*DeleteShowcase200Response, *http.Response, error) {
	return r.ApiService.UpdateShowcaseExecute(r)
}

func (r ShopAPIUpdateShowcaseRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*DeleteShowcase200Response, *http.Response, error) {
	return r.ApiService.UpdateShowcaseExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
UpdateShowcase Method for UpdateShowcase

This endpoint used to update existing showcase based on showcase_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ShopAPIUpdateShowcaseRequest
*/
func (a *ShopAPIService) UpdateShowcase(ctx context.Context, fsId int64) ShopAPIUpdateShowcaseRequest {
	return ShopAPIUpdateShowcaseRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return DeleteShowcase200Response
func (a *ShopAPIService) UpdateShowcaseExecute(r ShopAPIUpdateShowcaseRequest) (*DeleteShowcase200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteShowcase200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.UpdateShowcase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/showcase/fs/{fs_id}/update"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.updateShowcaseRequest == nil {
		return localVarReturnValue, nil, reportError("updateShowcaseRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateShowcaseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return DeleteShowcase200Response
func (a *ShopAPIService) UpdateShowcaseExecuteWithRetry(r ShopAPIUpdateShowcaseRequest, maxRetry, maxDelayMs int) (*DeleteShowcase200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteShowcase200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopAPIService.UpdateShowcase")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/showcase/fs/{fs_id}/update"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.updateShowcaseRequest == nil {
		return localVarReturnValue, nil, reportError("updateShowcaseRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateShowcaseRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
