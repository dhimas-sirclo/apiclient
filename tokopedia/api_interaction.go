/*
Tokopedia API

Tokopedia API

API version: 1.0
Contact: dev@sirclo.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tokopedia

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type InteractionAPI interface {

	/*
	GetListMessage Method for GetListMessage

	This endpoint retrieves a list of all messages (chatrooms) owned by a shop_id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return InteractionAPIGetListMessageRequest
	*/
	GetListMessage(ctx context.Context, fsId int64) InteractionAPIGetListMessageRequest

	// GetListMessageExecute executes the request
	//  @return GetListMessageDefaultResponse
	GetListMessageExecute(r InteractionAPIGetListMessageRequest) (*GetListMessageDefaultResponse, *http.Response, error)

	// GetListMessageExecuteWithRetry executes the request with retry
	//  @return GetListMessageDefaultResponse
	GetListMessageExecuteWithRetry(r InteractionAPIGetListMessageRequest, maxRetry, maxDelayMs int) (*GetListMessageDefaultResponse, *http.Response, error)

	/*
	GetListReply Method for GetListReply

	This endpoint retrieves a list of all replies (chat bubble) for a msg_id which is owned by a shop_id.x

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@param msgId Message service unique identifier
	@return InteractionAPIGetListReplyRequest
	*/
	GetListReply(ctx context.Context, fsId int64, msgId int64) InteractionAPIGetListReplyRequest

	// GetListReplyExecute executes the request
	//  @return GetListReply200Response
	GetListReplyExecute(r InteractionAPIGetListReplyRequest) (*GetListReply200Response, *http.Response, error)

	// GetListReplyExecuteWithRetry executes the request with retry
	//  @return GetListReply200Response
	GetListReplyExecuteWithRetry(r InteractionAPIGetListReplyRequest, maxRetry, maxDelayMs int) (*GetListReply200Response, *http.Response, error)

	/*
	InitiateChat Method for InitiateChat

	This endpoint check if chat message exists, if it doesn’t, creates a new message. The response consists of a list of replies in a message status.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return InteractionAPIInitiateChatRequest
	*/
	InitiateChat(ctx context.Context, fsId int64) InteractionAPIInitiateChatRequest

	// InitiateChatExecute executes the request
	//  @return InitiateChat200Response
	InitiateChatExecute(r InteractionAPIInitiateChatRequest) (*InitiateChat200Response, *http.Response, error)

	// InitiateChatExecuteWithRetry executes the request with retry
	//  @return InitiateChat200Response
	InitiateChatExecuteWithRetry(r InteractionAPIInitiateChatRequest, maxRetry, maxDelayMs int) (*InitiateChat200Response, *http.Response, error)

	/*
	SendReply Method for SendReply

	This endpoint sends a reply to a message (chat room) identified by msg_id from shop_id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@param msgId Message service unique identifier
	@return InteractionAPISendReplyRequest
	*/
	SendReply(ctx context.Context, fsId int64, msgId int64) InteractionAPISendReplyRequest

	// SendReplyExecute executes the request
	//  @return SendReply200Response
	SendReplyExecute(r InteractionAPISendReplyRequest) (*SendReply200Response, *http.Response, error)

	// SendReplyExecuteWithRetry executes the request with retry
	//  @return SendReply200Response
	SendReplyExecuteWithRetry(r InteractionAPISendReplyRequest, maxRetry, maxDelayMs int) (*SendReply200Response, *http.Response, error)
}

// InteractionAPIService InteractionAPI service
type InteractionAPIService service

type InteractionAPIGetListMessageRequest struct {
	ctx context.Context
	ApiService InteractionAPI
	fsId int64
	shopId *int64
	page *int64
	perPage *int64
	filter *string
}

// Shop service unique identifier
func (r InteractionAPIGetListMessageRequest) ShopId(shopId int64) InteractionAPIGetListMessageRequest {
	r.shopId = &shopId
	return r
}

// Determine which page the order list should start. Start from 1. You can get the next page when the previous page has have_next_page value true
func (r InteractionAPIGetListMessageRequest) Page(page int64) InteractionAPIGetListMessageRequest {
	r.page = &page
	return r
}

// Determine how many orders will be shown per page. The maximum value is 15
func (r InteractionAPIGetListMessageRequest) PerPage(perPage int64) InteractionAPIGetListMessageRequest {
	r.perPage = &perPage
	return r
}

// Filter by message read status. Value between “all”, “read”, or “unread”identifier
func (r InteractionAPIGetListMessageRequest) Filter(filter string) InteractionAPIGetListMessageRequest {
	r.filter = &filter
	return r
}

func (r InteractionAPIGetListMessageRequest) Execute() (*GetListMessageDefaultResponse, *http.Response, error) {
	return r.ApiService.GetListMessageExecute(r)
}

func (r InteractionAPIGetListMessageRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*GetListMessageDefaultResponse, *http.Response, error) {
	return r.ApiService.GetListMessageExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetListMessage Method for GetListMessage

This endpoint retrieves a list of all messages (chatrooms) owned by a shop_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return InteractionAPIGetListMessageRequest
*/
func (a *InteractionAPIService) GetListMessage(ctx context.Context, fsId int64) InteractionAPIGetListMessageRequest {
	return InteractionAPIGetListMessageRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return GetListMessageDefaultResponse
func (a *InteractionAPIService) GetListMessageExecute(r InteractionAPIGetListMessageRequest) (*GetListMessageDefaultResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetListMessageDefaultResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.GetListMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/chat/fs/{fs_id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetListMessageDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return GetListMessageDefaultResponse
func (a *InteractionAPIService) GetListMessageExecuteWithRetry(r InteractionAPIGetListMessageRequest, maxRetry, maxDelayMs int) (*GetListMessageDefaultResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetListMessageDefaultResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.GetListMessage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/chat/fs/{fs_id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetListMessageDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InteractionAPIGetListReplyRequest struct {
	ctx context.Context
	ApiService InteractionAPI
	fsId int64
	msgId int64
	shopId *int64
	page *int64
	perPage *int64
}

// Shop service unique identifier
func (r InteractionAPIGetListReplyRequest) ShopId(shopId int64) InteractionAPIGetListReplyRequest {
	r.shopId = &shopId
	return r
}

// Determine which page the order list should start. Start from 1. You can get the next page when the previous page has have_next_page value true
func (r InteractionAPIGetListReplyRequest) Page(page int64) InteractionAPIGetListReplyRequest {
	r.page = &page
	return r
}

// Determine how many orders will be shown per page. The maximum value is 15
func (r InteractionAPIGetListReplyRequest) PerPage(perPage int64) InteractionAPIGetListReplyRequest {
	r.perPage = &perPage
	return r
}

func (r InteractionAPIGetListReplyRequest) Execute() (*GetListReply200Response, *http.Response, error) {
	return r.ApiService.GetListReplyExecute(r)
}

func (r InteractionAPIGetListReplyRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*GetListReply200Response, *http.Response, error) {
	return r.ApiService.GetListReplyExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetListReply Method for GetListReply

This endpoint retrieves a list of all replies (chat bubble) for a msg_id which is owned by a shop_id.x

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @param msgId Message service unique identifier
 @return InteractionAPIGetListReplyRequest
*/
func (a *InteractionAPIService) GetListReply(ctx context.Context, fsId int64, msgId int64) InteractionAPIGetListReplyRequest {
	return InteractionAPIGetListReplyRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
		msgId: msgId,
	}
}

// Execute executes the request
//  @return GetListReply200Response
func (a *InteractionAPIService) GetListReplyExecute(r InteractionAPIGetListReplyRequest) (*GetListReply200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetListReply200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.GetListReply")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/chat/fs/{fs_id}/messages/{msg_id}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"msg_id"+"}", url.PathEscape(parameterValueToString(r.msgId, "msgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return GetListReply200Response
func (a *InteractionAPIService) GetListReplyExecuteWithRetry(r InteractionAPIGetListReplyRequest, maxRetry, maxDelayMs int) (*GetListReply200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetListReply200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.GetListReply")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/chat/fs/{fs_id}/messages/{msg_id}/replies"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"msg_id"+"}", url.PathEscape(parameterValueToString(r.msgId, "msgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InteractionAPIInitiateChatRequest struct {
	ctx context.Context
	ApiService InteractionAPI
	fsId int64
	orderId *int64
}

// Order service unique identifier
func (r InteractionAPIInitiateChatRequest) OrderId(orderId int64) InteractionAPIInitiateChatRequest {
	r.orderId = &orderId
	return r
}

func (r InteractionAPIInitiateChatRequest) Execute() (*InitiateChat200Response, *http.Response, error) {
	return r.ApiService.InitiateChatExecute(r)
}

func (r InteractionAPIInitiateChatRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*InitiateChat200Response, *http.Response, error) {
	return r.ApiService.InitiateChatExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
InitiateChat Method for InitiateChat

This endpoint check if chat message exists, if it doesn’t, creates a new message. The response consists of a list of replies in a message status.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return InteractionAPIInitiateChatRequest
*/
func (a *InteractionAPIService) InitiateChat(ctx context.Context, fsId int64) InteractionAPIInitiateChatRequest {
	return InteractionAPIInitiateChatRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return InitiateChat200Response
func (a *InteractionAPIService) InitiateChatExecute(r InteractionAPIInitiateChatRequest) (*InitiateChat200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InitiateChat200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.InitiateChat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/chat/fs/{fs_id}/initiate"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderId == nil {
		return localVarReturnValue, nil, reportError("orderId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "order_id", r.orderId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return InitiateChat200Response
func (a *InteractionAPIService) InitiateChatExecuteWithRetry(r InteractionAPIInitiateChatRequest, maxRetry, maxDelayMs int) (*InitiateChat200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InitiateChat200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.InitiateChat")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/chat/fs/{fs_id}/initiate"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.orderId == nil {
		return localVarReturnValue, nil, reportError("orderId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "order_id", r.orderId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InteractionAPISendReplyRequest struct {
	ctx context.Context
	ApiService InteractionAPI
	fsId int64
	msgId int64
	sendReplyRequest *SendReplyRequest
}

func (r InteractionAPISendReplyRequest) SendReplyRequest(sendReplyRequest SendReplyRequest) InteractionAPISendReplyRequest {
	r.sendReplyRequest = &sendReplyRequest
	return r
}

func (r InteractionAPISendReplyRequest) Execute() (*SendReply200Response, *http.Response, error) {
	return r.ApiService.SendReplyExecute(r)
}

func (r InteractionAPISendReplyRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*SendReply200Response, *http.Response, error) {
	return r.ApiService.SendReplyExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
SendReply Method for SendReply

This endpoint sends a reply to a message (chat room) identified by msg_id from shop_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @param msgId Message service unique identifier
 @return InteractionAPISendReplyRequest
*/
func (a *InteractionAPIService) SendReply(ctx context.Context, fsId int64, msgId int64) InteractionAPISendReplyRequest {
	return InteractionAPISendReplyRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
		msgId: msgId,
	}
}

// Execute executes the request
//  @return SendReply200Response
func (a *InteractionAPIService) SendReplyExecute(r InteractionAPISendReplyRequest) (*SendReply200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendReply200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.SendReply")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/chat/fs/{fs_id}/messages/{msg_id}/reply"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"msg_id"+"}", url.PathEscape(parameterValueToString(r.msgId, "msgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sendReplyRequest == nil {
		return localVarReturnValue, nil, reportError("sendReplyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendReplyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return SendReply200Response
func (a *InteractionAPIService) SendReplyExecuteWithRetry(r InteractionAPISendReplyRequest, maxRetry, maxDelayMs int) (*SendReply200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SendReply200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InteractionAPIService.SendReply")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/chat/fs/{fs_id}/messages/{msg_id}/reply"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"msg_id"+"}", url.PathEscape(parameterValueToString(r.msgId, "msgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sendReplyRequest == nil {
		return localVarReturnValue, nil, reportError("sendReplyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendReplyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
