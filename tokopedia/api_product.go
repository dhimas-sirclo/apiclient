/*
Tokopedia API

Tokopedia API

API version: 1.0
Contact: dev@sirclo.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tokopedia

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ProductAPI interface {

	/*
	DeleteProduct Method for DeleteProduct

	This endpoint use to delete product from a shop, this endpoint could do bulk delete product by product_id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPIDeleteProductRequest
	*/
	DeleteProduct(ctx context.Context, fsId int64) ProductAPIDeleteProductRequest

	// DeleteProductExecute executes the request
	//  @return DeleteProductDefaultResponse
	DeleteProductExecute(r ProductAPIDeleteProductRequest) (*DeleteProductDefaultResponse, *http.Response, error)

	// DeleteProductExecuteWithRetry executes the request with retry
	//  @return DeleteProductDefaultResponse
	DeleteProductExecuteWithRetry(r ProductAPIDeleteProductRequest, maxRetry, maxDelayMs int) (*DeleteProductDefaultResponse, *http.Response, error)

	/*
	GetAllCategories Method for GetAllCategories

	This endpoint retrieves a list of all categories and its children.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPIGetAllCategoriesRequest
	*/
	GetAllCategories(ctx context.Context, fsId int64) ProductAPIGetAllCategoriesRequest

	// GetAllCategoriesExecute executes the request
	//  @return GetAllCategories200Response
	GetAllCategoriesExecute(r ProductAPIGetAllCategoriesRequest) (*GetAllCategories200Response, *http.Response, error)

	// GetAllCategoriesExecuteWithRetry executes the request with retry
	//  @return GetAllCategories200Response
	GetAllCategoriesExecuteWithRetry(r ProductAPIGetAllCategoriesRequest, maxRetry, maxDelayMs int) (*GetAllCategories200Response, *http.Response, error)

	/*
	GetProductAnnotationByCategoryId Method for GetProductAnnotationByCategoryId

	This endpoint retrieve list of product annotation (product specification) based on category ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPIGetProductAnnotationByCategoryIdRequest
	*/
	GetProductAnnotationByCategoryId(ctx context.Context, fsId int64) ProductAPIGetProductAnnotationByCategoryIdRequest

	// GetProductAnnotationByCategoryIdExecute executes the request
	//  @return GetProductAnnotationByCategoryId200Response
	GetProductAnnotationByCategoryIdExecute(r ProductAPIGetProductAnnotationByCategoryIdRequest) (*GetProductAnnotationByCategoryId200Response, *http.Response, error)

	// GetProductAnnotationByCategoryIdExecuteWithRetry executes the request with retry
	//  @return GetProductAnnotationByCategoryId200Response
	GetProductAnnotationByCategoryIdExecuteWithRetry(r ProductAPIGetProductAnnotationByCategoryIdRequest, maxRetry, maxDelayMs int) (*GetProductAnnotationByCategoryId200Response, *http.Response, error)

	/*
	GetProductDiscussion Method for GetProductDiscussion

	This endpoint retrieves a list of all Discussion owned by a product_id, shop_id needed for validate that product is owned by shop.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPIGetProductDiscussionRequest
	*/
	GetProductDiscussion(ctx context.Context, fsId int64) ProductAPIGetProductDiscussionRequest

	// GetProductDiscussionExecute executes the request
	//  @return GetProductDiscussion200Response
	GetProductDiscussionExecute(r ProductAPIGetProductDiscussionRequest) (*GetProductDiscussion200Response, *http.Response, error)

	// GetProductDiscussionExecuteWithRetry executes the request with retry
	//  @return GetProductDiscussion200Response
	GetProductDiscussionExecuteWithRetry(r ProductAPIGetProductDiscussionRequest, maxRetry, maxDelayMs int) (*GetProductDiscussion200Response, *http.Response, error)

	/*
	GetProductInfo Method for GetProductInfo

	This method will retrieve single product information either by product id as parameter (choose one of those two parameters to use) from related fs_id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPIGetProductInfoRequest
	*/
	GetProductInfo(ctx context.Context, fsId int64) ProductAPIGetProductInfoRequest

	// GetProductInfoExecute executes the request
	//  @return GetProductInfoResponse
	GetProductInfoExecute(r ProductAPIGetProductInfoRequest) (*GetProductInfoResponse, *http.Response, error)

	// GetProductInfoExecuteWithRetry executes the request with retry
	//  @return GetProductInfoResponse
	GetProductInfoExecuteWithRetry(r ProductAPIGetProductInfoRequest, maxRetry, maxDelayMs int) (*GetProductInfoResponse, *http.Response, error)

	/*
	GetVariantsByCategoryId Method for GetVariantsByCategoryId

	This endpoint retrieves a list of variants related to a category_id. Use this API as main source to retrieve the newest category variant data.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPIGetVariantsByCategoryIdRequest
	*/
	GetVariantsByCategoryId(ctx context.Context, fsId int64) ProductAPIGetVariantsByCategoryIdRequest

	// GetVariantsByCategoryIdExecute executes the request
	//  @return CategoryVariants
	GetVariantsByCategoryIdExecute(r ProductAPIGetVariantsByCategoryIdRequest) (*CategoryVariants, *http.Response, error)

	// GetVariantsByCategoryIdExecuteWithRetry executes the request with retry
	//  @return CategoryVariants
	GetVariantsByCategoryIdExecuteWithRetry(r ProductAPIGetVariantsByCategoryIdRequest, maxRetry, maxDelayMs int) (*CategoryVariants, *http.Response, error)

	/*
	GetVariantsByProductId Method for GetVariantsByProductId

	This endpoint retrieves a list of variants related to a product_id.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@param productId Product unique identifier
	@return ProductAPIGetVariantsByProductIdRequest
	*/
	GetVariantsByProductId(ctx context.Context, fsId int64, productId int64) ProductAPIGetVariantsByProductIdRequest

	// GetVariantsByProductIdExecute executes the request
	//  @return GetProductVariantResponse
	GetVariantsByProductIdExecute(r ProductAPIGetVariantsByProductIdRequest) (*GetProductVariantResponse, *http.Response, error)

	// GetVariantsByProductIdExecuteWithRetry executes the request with retry
	//  @return GetProductVariantResponse
	GetVariantsByProductIdExecuteWithRetry(r ProductAPIGetVariantsByProductIdRequest, maxRetry, maxDelayMs int) (*GetProductVariantResponse, *http.Response, error)

	/*
	SetActiveProduct Method for SetActiveProduct

	This endpoint use to set the product into active product status without changing the product’s current stock. The product that can be updated is up to 25 products at one request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPISetActiveProductRequest
	*/
	SetActiveProduct(ctx context.Context, fsId int64) ProductAPISetActiveProductRequest

	// SetActiveProductExecute executes the request
	//  @return CancelSlashPrice200Response
	SetActiveProductExecute(r ProductAPISetActiveProductRequest) (*CancelSlashPrice200Response, *http.Response, error)

	// SetActiveProductExecuteWithRetry executes the request with retry
	//  @return CancelSlashPrice200Response
	SetActiveProductExecuteWithRetry(r ProductAPISetActiveProductRequest, maxRetry, maxDelayMs int) (*CancelSlashPrice200Response, *http.Response, error)

	/*
	SetInactiveProduct Method for SetInactiveProduct

	This endpoint use to set the product into inactive product status without changing the product’s current stock. The product that can be updated is up to 25 products at one request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPISetInactiveProductRequest
	*/
	SetInactiveProduct(ctx context.Context, fsId int64) ProductAPISetInactiveProductRequest

	// SetInactiveProductExecute executes the request
	//  @return CancelSlashPrice200Response
	SetInactiveProductExecute(r ProductAPISetInactiveProductRequest) (*CancelSlashPrice200Response, *http.Response, error)

	// SetInactiveProductExecuteWithRetry executes the request with retry
	//  @return CancelSlashPrice200Response
	SetInactiveProductExecuteWithRetry(r ProductAPISetInactiveProductRequest, maxRetry, maxDelayMs int) (*CancelSlashPrice200Response, *http.Response, error)

	/*
	UpdatePrice Method for UpdatePrice

	This endpoint used for update product’s price. You can update up to 100 products or SKUs in a single request to this endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPIUpdatePriceRequest
	*/
	UpdatePrice(ctx context.Context, fsId int64) ProductAPIUpdatePriceRequest

	// UpdatePriceExecute executes the request
	//  @return UpdatePriceDefaultResponse
	UpdatePriceExecute(r ProductAPIUpdatePriceRequest) (*UpdatePriceDefaultResponse, *http.Response, error)

	// UpdatePriceExecuteWithRetry executes the request with retry
	//  @return UpdatePriceDefaultResponse
	UpdatePriceExecuteWithRetry(r ProductAPIUpdatePriceRequest, maxRetry, maxDelayMs int) (*UpdatePriceDefaultResponse, *http.Response, error)

	/*
	UpdateStockDecrement Method for UpdateStockDecrement

	This endpoint is used to update stock by decreasing based on input value. You can update up to 100 products or SKUs in a single request by using this endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPIUpdateStockDecrementRequest
	*/
	UpdateStockDecrement(ctx context.Context, fsId int64) ProductAPIUpdateStockDecrementRequest

	// UpdateStockDecrementExecute executes the request
	//  @return DecreaseStockResponse
	UpdateStockDecrementExecute(r ProductAPIUpdateStockDecrementRequest) (*DecreaseStockResponse, *http.Response, error)

	// UpdateStockDecrementExecuteWithRetry executes the request with retry
	//  @return DecreaseStockResponse
	UpdateStockDecrementExecuteWithRetry(r ProductAPIUpdateStockDecrementRequest, maxRetry, maxDelayMs int) (*DecreaseStockResponse, *http.Response, error)

	/*
	UpdateStockIncrement Method for UpdateStockIncrement

	This endpoint is used to update stock by increasing based on input value. You can update up to 100 products or SKUs in a single request by using this endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPIUpdateStockIncrementRequest
	*/
	UpdateStockIncrement(ctx context.Context, fsId int64) ProductAPIUpdateStockIncrementRequest

	// UpdateStockIncrementExecute executes the request
	//  @return IncreaseStockResponse
	UpdateStockIncrementExecute(r ProductAPIUpdateStockIncrementRequest) (*IncreaseStockResponse, *http.Response, error)

	// UpdateStockIncrementExecuteWithRetry executes the request with retry
	//  @return IncreaseStockResponse
	UpdateStockIncrementExecuteWithRetry(r ProductAPIUpdateStockIncrementRequest, maxRetry, maxDelayMs int) (*IncreaseStockResponse, *http.Response, error)

	/*
	UpdateStockOverwrite Method for UpdateStockOverwrite

	This endpoint used for update product stock. You can update up to 100 products or SKUs in a single request to this endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@return ProductAPIUpdateStockOverwriteRequest
	*/
	UpdateStockOverwrite(ctx context.Context, fsId int64) ProductAPIUpdateStockOverwriteRequest

	// UpdateStockOverwriteExecute executes the request
	//  @return UpdateStockResponse
	UpdateStockOverwriteExecute(r ProductAPIUpdateStockOverwriteRequest) (*UpdateStockResponse, *http.Response, error)

	// UpdateStockOverwriteExecuteWithRetry executes the request with retry
	//  @return UpdateStockResponse
	UpdateStockOverwriteExecuteWithRetry(r ProductAPIUpdateStockOverwriteRequest, maxRetry, maxDelayMs int) (*UpdateStockResponse, *http.Response, error)
}

// ProductAPIService ProductAPI service
type ProductAPIService service

type ProductAPIDeleteProductRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	shopId *int64
	deleteProductRequest *DeleteProductRequest
}

// Shop unique identifier
func (r ProductAPIDeleteProductRequest) ShopId(shopId int64) ProductAPIDeleteProductRequest {
	r.shopId = &shopId
	return r
}

func (r ProductAPIDeleteProductRequest) DeleteProductRequest(deleteProductRequest DeleteProductRequest) ProductAPIDeleteProductRequest {
	r.deleteProductRequest = &deleteProductRequest
	return r
}

func (r ProductAPIDeleteProductRequest) Execute() (*DeleteProductDefaultResponse, *http.Response, error) {
	return r.ApiService.DeleteProductExecute(r)
}

func (r ProductAPIDeleteProductRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*DeleteProductDefaultResponse, *http.Response, error) {
	return r.ApiService.DeleteProductExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
DeleteProduct Method for DeleteProduct

This endpoint use to delete product from a shop, this endpoint could do bulk delete product by product_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPIDeleteProductRequest
*/
func (a *ProductAPIService) DeleteProduct(ctx context.Context, fsId int64) ProductAPIDeleteProductRequest {
	return ProductAPIDeleteProductRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return DeleteProductDefaultResponse
func (a *ProductAPIService) DeleteProductExecute(r ProductAPIDeleteProductRequest) (*DeleteProductDefaultResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteProductDefaultResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.DeleteProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/products/fs/{fs_id}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.deleteProductRequest == nil {
		return localVarReturnValue, nil, reportError("deleteProductRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteProductRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v DeleteProductDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return DeleteProductDefaultResponse
func (a *ProductAPIService) DeleteProductExecuteWithRetry(r ProductAPIDeleteProductRequest, maxRetry, maxDelayMs int) (*DeleteProductDefaultResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteProductDefaultResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.DeleteProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/products/fs/{fs_id}/delete"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.deleteProductRequest == nil {
		return localVarReturnValue, nil, reportError("deleteProductRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteProductRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v DeleteProductDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIGetAllCategoriesRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	keyword *string
}

// Keyword or Product Name to get recommended category. Leave it blank to get full categories
func (r ProductAPIGetAllCategoriesRequest) Keyword(keyword string) ProductAPIGetAllCategoriesRequest {
	r.keyword = &keyword
	return r
}

func (r ProductAPIGetAllCategoriesRequest) Execute() (*GetAllCategories200Response, *http.Response, error) {
	return r.ApiService.GetAllCategoriesExecute(r)
}

func (r ProductAPIGetAllCategoriesRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*GetAllCategories200Response, *http.Response, error) {
	return r.ApiService.GetAllCategoriesExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetAllCategories Method for GetAllCategories

This endpoint retrieves a list of all categories and its children.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPIGetAllCategoriesRequest
*/
func (a *ProductAPIService) GetAllCategories(ctx context.Context, fsId int64) ProductAPIGetAllCategoriesRequest {
	return ProductAPIGetAllCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return GetAllCategories200Response
func (a *ProductAPIService) GetAllCategoriesExecute(r ProductAPIGetAllCategoriesRequest) (*GetAllCategories200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllCategories200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetAllCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/product/category"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return GetAllCategories200Response
func (a *ProductAPIService) GetAllCategoriesExecuteWithRetry(r ProductAPIGetAllCategoriesRequest, maxRetry, maxDelayMs int) (*GetAllCategories200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllCategories200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetAllCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/product/category"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keyword != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyword", r.keyword, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/html", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIGetProductAnnotationByCategoryIdRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	catId *int64
}

// Category unique identifier
func (r ProductAPIGetProductAnnotationByCategoryIdRequest) CatId(catId int64) ProductAPIGetProductAnnotationByCategoryIdRequest {
	r.catId = &catId
	return r
}

func (r ProductAPIGetProductAnnotationByCategoryIdRequest) Execute() (*GetProductAnnotationByCategoryId200Response, *http.Response, error) {
	return r.ApiService.GetProductAnnotationByCategoryIdExecute(r)
}

func (r ProductAPIGetProductAnnotationByCategoryIdRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*GetProductAnnotationByCategoryId200Response, *http.Response, error) {
	return r.ApiService.GetProductAnnotationByCategoryIdExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetProductAnnotationByCategoryId Method for GetProductAnnotationByCategoryId

This endpoint retrieve list of product annotation (product specification) based on category ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPIGetProductAnnotationByCategoryIdRequest
*/
func (a *ProductAPIService) GetProductAnnotationByCategoryId(ctx context.Context, fsId int64) ProductAPIGetProductAnnotationByCategoryIdRequest {
	return ProductAPIGetProductAnnotationByCategoryIdRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return GetProductAnnotationByCategoryId200Response
func (a *ProductAPIService) GetProductAnnotationByCategoryIdExecute(r ProductAPIGetProductAnnotationByCategoryIdRequest) (*GetProductAnnotationByCategoryId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProductAnnotationByCategoryId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetProductAnnotationByCategoryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/fs/{fs_id}/product/annotation"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.catId == nil {
		return localVarReturnValue, nil, reportError("catId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cat_id", r.catId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return GetProductAnnotationByCategoryId200Response
func (a *ProductAPIService) GetProductAnnotationByCategoryIdExecuteWithRetry(r ProductAPIGetProductAnnotationByCategoryIdRequest, maxRetry, maxDelayMs int) (*GetProductAnnotationByCategoryId200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProductAnnotationByCategoryId200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetProductAnnotationByCategoryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/fs/{fs_id}/product/annotation"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.catId == nil {
		return localVarReturnValue, nil, reportError("catId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cat_id", r.catId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIGetProductDiscussionRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	shopId *int64
	productId *int64
	page *int64
	perPage *int64
}

// Shop unique identifier
func (r ProductAPIGetProductDiscussionRequest) ShopId(shopId int64) ProductAPIGetProductDiscussionRequest {
	r.shopId = &shopId
	return r
}

// List of Product ID
func (r ProductAPIGetProductDiscussionRequest) ProductId(productId int64) ProductAPIGetProductDiscussionRequest {
	r.productId = &productId
	return r
}

// Determine which page the order list should start. The minimal value is 1
func (r ProductAPIGetProductDiscussionRequest) Page(page int64) ProductAPIGetProductDiscussionRequest {
	r.page = &page
	return r
}

// Determine how many orders will be shown per page. The maximal value is 10
func (r ProductAPIGetProductDiscussionRequest) PerPage(perPage int64) ProductAPIGetProductDiscussionRequest {
	r.perPage = &perPage
	return r
}

func (r ProductAPIGetProductDiscussionRequest) Execute() (*GetProductDiscussion200Response, *http.Response, error) {
	return r.ApiService.GetProductDiscussionExecute(r)
}

func (r ProductAPIGetProductDiscussionRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*GetProductDiscussion200Response, *http.Response, error) {
	return r.ApiService.GetProductDiscussionExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetProductDiscussion Method for GetProductDiscussion

This endpoint retrieves a list of all Discussion owned by a product_id, shop_id needed for validate that product is owned by shop.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPIGetProductDiscussionRequest
*/
func (a *ProductAPIService) GetProductDiscussion(ctx context.Context, fsId int64) ProductAPIGetProductDiscussionRequest {
	return ProductAPIGetProductDiscussionRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return GetProductDiscussion200Response
func (a *ProductAPIService) GetProductDiscussionExecute(r ProductAPIGetProductDiscussionRequest) (*GetProductDiscussion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProductDiscussion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetProductDiscussion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/discussion/fs/{fs_id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if *r.page < 1 {
		return localVarReturnValue, nil, reportError("page must be greater than 1")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}
	if *r.perPage > 10 {
		return localVarReturnValue, nil, reportError("perPage must be less than 10")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return GetProductDiscussion200Response
func (a *ProductAPIService) GetProductDiscussionExecuteWithRetry(r ProductAPIGetProductDiscussionRequest, maxRetry, maxDelayMs int) (*GetProductDiscussion200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProductDiscussion200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetProductDiscussion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/discussion/fs/{fs_id}/list"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if *r.page < 1 {
		return localVarReturnValue, nil, reportError("page must be greater than 1")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}
	if *r.perPage > 10 {
		return localVarReturnValue, nil, reportError("perPage must be less than 10")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "product_id", r.productId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIGetProductInfoRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	product *string
	productUrl *string
	sku *string
	shopId *int64
	page *int64
	perPage *int64
	lastSort *string
}

// Can input more than one product_id
func (r ProductAPIGetProductInfoRequest) Product(product string) ProductAPIGetProductInfoRequest {
	r.product = &product
	return r
}

// Can input more than one product_url
func (r ProductAPIGetProductInfoRequest) ProductUrl(productUrl string) ProductAPIGetProductInfoRequest {
	r.productUrl = &productUrl
	return r
}

// Product’s SKU
func (r ProductAPIGetProductInfoRequest) Sku(sku string) ProductAPIGetProductInfoRequest {
	r.sku = &sku
	return r
}

// Shop Identifier
func (r ProductAPIGetProductInfoRequest) ShopId(shopId int64) ProductAPIGetProductInfoRequest {
	r.shopId = &shopId
	return r
}

// Determine which page the order list should start. The minimal value is 1. Page (required if shop_id is filled)
func (r ProductAPIGetProductInfoRequest) Page(page int64) ProductAPIGetProductInfoRequest {
	r.page = &page
	return r
}

// Page per item (required if shop_id is filled). Maximun items are 50 for 1 page
func (r ProductAPIGetProductInfoRequest) PerPage(perPage int64) ProductAPIGetProductInfoRequest {
	r.perPage = &perPage
	return r
}

// This parameter is required when the product exceeds 10.000 products
func (r ProductAPIGetProductInfoRequest) LastSort(lastSort string) ProductAPIGetProductInfoRequest {
	r.lastSort = &lastSort
	return r
}

func (r ProductAPIGetProductInfoRequest) Execute() (*GetProductInfoResponse, *http.Response, error) {
	return r.ApiService.GetProductInfoExecute(r)
}

func (r ProductAPIGetProductInfoRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*GetProductInfoResponse, *http.Response, error) {
	return r.ApiService.GetProductInfoExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetProductInfo Method for GetProductInfo

This method will retrieve single product information either by product id as parameter (choose one of those two parameters to use) from related fs_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPIGetProductInfoRequest
*/
func (a *ProductAPIService) GetProductInfo(ctx context.Context, fsId int64) ProductAPIGetProductInfoRequest {
	return ProductAPIGetProductInfoRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return GetProductInfoResponse
func (a *ProductAPIService) GetProductInfoExecute(r ProductAPIGetProductInfoRequest) (*GetProductInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProductInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetProductInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/product/info"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.product != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product", r.product, "")
	}
	if r.productUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_url", r.productUrl, "")
	}
	if r.sku != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sku", r.sku, "")
	}
	if r.shopId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.lastSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_sort", r.lastSort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return GetProductInfoResponse
func (a *ProductAPIService) GetProductInfoExecuteWithRetry(r ProductAPIGetProductInfoRequest, maxRetry, maxDelayMs int) (*GetProductInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProductInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetProductInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/product/info"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.product != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product", r.product, "")
	}
	if r.productUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product_url", r.productUrl, "")
	}
	if r.sku != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sku", r.sku, "")
	}
	if r.shopId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.lastSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_sort", r.lastSort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIGetVariantsByCategoryIdRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	catId *int64
}

// Category unique identifier
func (r ProductAPIGetVariantsByCategoryIdRequest) CatId(catId int64) ProductAPIGetVariantsByCategoryIdRequest {
	r.catId = &catId
	return r
}

func (r ProductAPIGetVariantsByCategoryIdRequest) Execute() (*CategoryVariants, *http.Response, error) {
	return r.ApiService.GetVariantsByCategoryIdExecute(r)
}

func (r ProductAPIGetVariantsByCategoryIdRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*CategoryVariants, *http.Response, error) {
	return r.ApiService.GetVariantsByCategoryIdExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetVariantsByCategoryId Method for GetVariantsByCategoryId

This endpoint retrieves a list of variants related to a category_id. Use this API as main source to retrieve the newest category variant data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPIGetVariantsByCategoryIdRequest
*/
func (a *ProductAPIService) GetVariantsByCategoryId(ctx context.Context, fsId int64) ProductAPIGetVariantsByCategoryIdRequest {
	return ProductAPIGetVariantsByCategoryIdRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return CategoryVariants
func (a *ProductAPIService) GetVariantsByCategoryIdExecute(r ProductAPIGetVariantsByCategoryIdRequest) (*CategoryVariants, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryVariants
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetVariantsByCategoryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v2/fs/{fs_id}/category/get_variant"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.catId == nil {
		return localVarReturnValue, nil, reportError("catId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cat_id", r.catId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return CategoryVariants
func (a *ProductAPIService) GetVariantsByCategoryIdExecuteWithRetry(r ProductAPIGetVariantsByCategoryIdRequest, maxRetry, maxDelayMs int) (*CategoryVariants, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CategoryVariants
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetVariantsByCategoryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v2/fs/{fs_id}/category/get_variant"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.catId == nil {
		return localVarReturnValue, nil, reportError("catId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "cat_id", r.catId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIGetVariantsByProductIdRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	productId int64
}

func (r ProductAPIGetVariantsByProductIdRequest) Execute() (*GetProductVariantResponse, *http.Response, error) {
	return r.ApiService.GetVariantsByProductIdExecute(r)
}

func (r ProductAPIGetVariantsByProductIdRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*GetProductVariantResponse, *http.Response, error) {
	return r.ApiService.GetVariantsByProductIdExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetVariantsByProductId Method for GetVariantsByProductId

This endpoint retrieves a list of variants related to a product_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @param productId Product unique identifier
 @return ProductAPIGetVariantsByProductIdRequest
*/
func (a *ProductAPIService) GetVariantsByProductId(ctx context.Context, fsId int64, productId int64) ProductAPIGetVariantsByProductIdRequest {
	return ProductAPIGetVariantsByProductIdRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
		productId: productId,
	}
}

// Execute executes the request
//  @return GetProductVariantResponse
func (a *ProductAPIService) GetVariantsByProductIdExecute(r ProductAPIGetVariantsByProductIdRequest) (*GetProductVariantResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProductVariantResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetVariantsByProductId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/product/variant/{product_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return GetProductVariantResponse
func (a *ProductAPIService) GetVariantsByProductIdExecuteWithRetry(r ProductAPIGetVariantsByProductIdRequest, maxRetry, maxDelayMs int) (*GetProductVariantResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProductVariantResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.GetVariantsByProductId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/product/variant/{product_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPISetActiveProductRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	shopId *int64
	setInactiveProductRequest *SetInactiveProductRequest
}

// Shop unique identifier
func (r ProductAPISetActiveProductRequest) ShopId(shopId int64) ProductAPISetActiveProductRequest {
	r.shopId = &shopId
	return r
}

func (r ProductAPISetActiveProductRequest) SetInactiveProductRequest(setInactiveProductRequest SetInactiveProductRequest) ProductAPISetActiveProductRequest {
	r.setInactiveProductRequest = &setInactiveProductRequest
	return r
}

func (r ProductAPISetActiveProductRequest) Execute() (*CancelSlashPrice200Response, *http.Response, error) {
	return r.ApiService.SetActiveProductExecute(r)
}

func (r ProductAPISetActiveProductRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*CancelSlashPrice200Response, *http.Response, error) {
	return r.ApiService.SetActiveProductExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
SetActiveProduct Method for SetActiveProduct

This endpoint use to set the product into active product status without changing the product’s current stock. The product that can be updated is up to 25 products at one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPISetActiveProductRequest
*/
func (a *ProductAPIService) SetActiveProduct(ctx context.Context, fsId int64) ProductAPISetActiveProductRequest {
	return ProductAPISetActiveProductRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return CancelSlashPrice200Response
func (a *ProductAPIService) SetActiveProductExecute(r ProductAPISetActiveProductRequest) (*CancelSlashPrice200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelSlashPrice200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.SetActiveProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/products/fs/{fs_id}/active"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.setInactiveProductRequest == nil {
		return localVarReturnValue, nil, reportError("setInactiveProductRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setInactiveProductRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v CancelSlashPriceDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return CancelSlashPrice200Response
func (a *ProductAPIService) SetActiveProductExecuteWithRetry(r ProductAPISetActiveProductRequest, maxRetry, maxDelayMs int) (*CancelSlashPrice200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelSlashPrice200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.SetActiveProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/products/fs/{fs_id}/active"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.setInactiveProductRequest == nil {
		return localVarReturnValue, nil, reportError("setInactiveProductRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setInactiveProductRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v CancelSlashPriceDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPISetInactiveProductRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	shopId *int64
	setInactiveProductRequest *SetInactiveProductRequest
}

// Shop unique identifier
func (r ProductAPISetInactiveProductRequest) ShopId(shopId int64) ProductAPISetInactiveProductRequest {
	r.shopId = &shopId
	return r
}

func (r ProductAPISetInactiveProductRequest) SetInactiveProductRequest(setInactiveProductRequest SetInactiveProductRequest) ProductAPISetInactiveProductRequest {
	r.setInactiveProductRequest = &setInactiveProductRequest
	return r
}

func (r ProductAPISetInactiveProductRequest) Execute() (*CancelSlashPrice200Response, *http.Response, error) {
	return r.ApiService.SetInactiveProductExecute(r)
}

func (r ProductAPISetInactiveProductRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*CancelSlashPrice200Response, *http.Response, error) {
	return r.ApiService.SetInactiveProductExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
SetInactiveProduct Method for SetInactiveProduct

This endpoint use to set the product into inactive product status without changing the product’s current stock. The product that can be updated is up to 25 products at one request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPISetInactiveProductRequest
*/
func (a *ProductAPIService) SetInactiveProduct(ctx context.Context, fsId int64) ProductAPISetInactiveProductRequest {
	return ProductAPISetInactiveProductRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return CancelSlashPrice200Response
func (a *ProductAPIService) SetInactiveProductExecute(r ProductAPISetInactiveProductRequest) (*CancelSlashPrice200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelSlashPrice200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.SetInactiveProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/products/fs/{fs_id}/inactive"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.setInactiveProductRequest == nil {
		return localVarReturnValue, nil, reportError("setInactiveProductRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setInactiveProductRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v CancelSlashPriceDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return CancelSlashPrice200Response
func (a *ProductAPIService) SetInactiveProductExecuteWithRetry(r ProductAPISetInactiveProductRequest, maxRetry, maxDelayMs int) (*CancelSlashPrice200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelSlashPrice200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.SetInactiveProduct")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/products/fs/{fs_id}/inactive"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.setInactiveProductRequest == nil {
		return localVarReturnValue, nil, reportError("setInactiveProductRequest is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setInactiveProductRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v CancelSlashPriceDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIUpdatePriceRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	shopId *int64
	updatePriceRequestInner *[]UpdatePriceRequestInner
	warehouseId *int64
}

// Shop unique identifier
func (r ProductAPIUpdatePriceRequest) ShopId(shopId int64) ProductAPIUpdatePriceRequest {
	r.shopId = &shopId
	return r
}

func (r ProductAPIUpdatePriceRequest) UpdatePriceRequestInner(updatePriceRequestInner []UpdatePriceRequestInner) ProductAPIUpdatePriceRequest {
	r.updatePriceRequestInner = &updatePriceRequestInner
	return r
}

// Warehouse unique identifer
func (r ProductAPIUpdatePriceRequest) WarehouseId(warehouseId int64) ProductAPIUpdatePriceRequest {
	r.warehouseId = &warehouseId
	return r
}

func (r ProductAPIUpdatePriceRequest) Execute() (*UpdatePriceDefaultResponse, *http.Response, error) {
	return r.ApiService.UpdatePriceExecute(r)
}

func (r ProductAPIUpdatePriceRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*UpdatePriceDefaultResponse, *http.Response, error) {
	return r.ApiService.UpdatePriceExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
UpdatePrice Method for UpdatePrice

This endpoint used for update product’s price. You can update up to 100 products or SKUs in a single request to this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPIUpdatePriceRequest
*/
func (a *ProductAPIService) UpdatePrice(ctx context.Context, fsId int64) ProductAPIUpdatePriceRequest {
	return ProductAPIUpdatePriceRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return UpdatePriceDefaultResponse
func (a *ProductAPIService) UpdatePriceExecute(r ProductAPIUpdatePriceRequest) (*UpdatePriceDefaultResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdatePriceDefaultResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.UpdatePrice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/price/update"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.updatePriceRequestInner == nil {
		return localVarReturnValue, nil, reportError("updatePriceRequestInner is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.warehouseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warehouse_id", r.warehouseId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePriceRequestInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v UpdatePriceDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return UpdatePriceDefaultResponse
func (a *ProductAPIService) UpdatePriceExecuteWithRetry(r ProductAPIUpdatePriceRequest, maxRetry, maxDelayMs int) (*UpdatePriceDefaultResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdatePriceDefaultResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.UpdatePrice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/price/update"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.updatePriceRequestInner == nil {
		return localVarReturnValue, nil, reportError("updatePriceRequestInner is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.warehouseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warehouse_id", r.warehouseId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePriceRequestInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v UpdatePriceDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIUpdateStockDecrementRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	shopId *int64
	updateStockIncrementRequestInner *[]UpdateStockIncrementRequestInner
	requestId *bool
	warehouseId *int64
}

// Shop unique identifier
func (r ProductAPIUpdateStockDecrementRequest) ShopId(shopId int64) ProductAPIUpdateStockDecrementRequest {
	r.shopId = &shopId
	return r
}

func (r ProductAPIUpdateStockDecrementRequest) UpdateStockIncrementRequestInner(updateStockIncrementRequestInner []UpdateStockIncrementRequestInner) ProductAPIUpdateStockDecrementRequest {
	r.updateStockIncrementRequestInner = &updateStockIncrementRequestInner
	return r
}

// The ID of the request to be used for duplicate request validation. Only alphanumeric (case insensitive), ‘-‘, and ‘_’ characters are allowed with a maximum of 20 characters long
func (r ProductAPIUpdateStockDecrementRequest) RequestId(requestId bool) ProductAPIUpdateStockDecrementRequest {
	r.requestId = &requestId
	return r
}

// Warehouse unique identifer
func (r ProductAPIUpdateStockDecrementRequest) WarehouseId(warehouseId int64) ProductAPIUpdateStockDecrementRequest {
	r.warehouseId = &warehouseId
	return r
}

func (r ProductAPIUpdateStockDecrementRequest) Execute() (*DecreaseStockResponse, *http.Response, error) {
	return r.ApiService.UpdateStockDecrementExecute(r)
}

func (r ProductAPIUpdateStockDecrementRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*DecreaseStockResponse, *http.Response, error) {
	return r.ApiService.UpdateStockDecrementExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
UpdateStockDecrement Method for UpdateStockDecrement

This endpoint is used to update stock by decreasing based on input value. You can update up to 100 products or SKUs in a single request by using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPIUpdateStockDecrementRequest
*/
func (a *ProductAPIService) UpdateStockDecrement(ctx context.Context, fsId int64) ProductAPIUpdateStockDecrementRequest {
	return ProductAPIUpdateStockDecrementRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return DecreaseStockResponse
func (a *ProductAPIService) UpdateStockDecrementExecute(r ProductAPIUpdateStockDecrementRequest) (*DecreaseStockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DecreaseStockResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.UpdateStockDecrement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/stock/decrement"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.updateStockIncrementRequestInner == nil {
		return localVarReturnValue, nil, reportError("updateStockIncrementRequestInner is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.requestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_id", r.requestId, "")
	}
	if r.warehouseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warehouse_id", r.warehouseId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateStockIncrementRequestInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return DecreaseStockResponse
func (a *ProductAPIService) UpdateStockDecrementExecuteWithRetry(r ProductAPIUpdateStockDecrementRequest, maxRetry, maxDelayMs int) (*DecreaseStockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DecreaseStockResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.UpdateStockDecrement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/stock/decrement"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.updateStockIncrementRequestInner == nil {
		return localVarReturnValue, nil, reportError("updateStockIncrementRequestInner is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.requestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_id", r.requestId, "")
	}
	if r.warehouseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warehouse_id", r.warehouseId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateStockIncrementRequestInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIUpdateStockIncrementRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	shopId *int64
	updateStockIncrementRequestInner *[]UpdateStockIncrementRequestInner
	requestId *bool
	warehouseId *int64
}

// Shop unique identifier
func (r ProductAPIUpdateStockIncrementRequest) ShopId(shopId int64) ProductAPIUpdateStockIncrementRequest {
	r.shopId = &shopId
	return r
}

func (r ProductAPIUpdateStockIncrementRequest) UpdateStockIncrementRequestInner(updateStockIncrementRequestInner []UpdateStockIncrementRequestInner) ProductAPIUpdateStockIncrementRequest {
	r.updateStockIncrementRequestInner = &updateStockIncrementRequestInner
	return r
}

// The ID of the request to be used for duplicate request validation. Only alphanumeric (case insensitive), ‘-‘, and ‘_’ characters are allowed with a maximum of 20 characters long
func (r ProductAPIUpdateStockIncrementRequest) RequestId(requestId bool) ProductAPIUpdateStockIncrementRequest {
	r.requestId = &requestId
	return r
}

// Warehouse unique identifer
func (r ProductAPIUpdateStockIncrementRequest) WarehouseId(warehouseId int64) ProductAPIUpdateStockIncrementRequest {
	r.warehouseId = &warehouseId
	return r
}

func (r ProductAPIUpdateStockIncrementRequest) Execute() (*IncreaseStockResponse, *http.Response, error) {
	return r.ApiService.UpdateStockIncrementExecute(r)
}

func (r ProductAPIUpdateStockIncrementRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*IncreaseStockResponse, *http.Response, error) {
	return r.ApiService.UpdateStockIncrementExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
UpdateStockIncrement Method for UpdateStockIncrement

This endpoint is used to update stock by increasing based on input value. You can update up to 100 products or SKUs in a single request by using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPIUpdateStockIncrementRequest
*/
func (a *ProductAPIService) UpdateStockIncrement(ctx context.Context, fsId int64) ProductAPIUpdateStockIncrementRequest {
	return ProductAPIUpdateStockIncrementRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return IncreaseStockResponse
func (a *ProductAPIService) UpdateStockIncrementExecute(r ProductAPIUpdateStockIncrementRequest) (*IncreaseStockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IncreaseStockResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.UpdateStockIncrement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/stock/increment"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.updateStockIncrementRequestInner == nil {
		return localVarReturnValue, nil, reportError("updateStockIncrementRequestInner is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.requestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_id", r.requestId, "")
	}
	if r.warehouseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warehouse_id", r.warehouseId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateStockIncrementRequestInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return IncreaseStockResponse
func (a *ProductAPIService) UpdateStockIncrementExecuteWithRetry(r ProductAPIUpdateStockIncrementRequest, maxRetry, maxDelayMs int) (*IncreaseStockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IncreaseStockResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.UpdateStockIncrement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/stock/increment"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.updateStockIncrementRequestInner == nil {
		return localVarReturnValue, nil, reportError("updateStockIncrementRequestInner is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.requestId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "request_id", r.requestId, "")
	}
	if r.warehouseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warehouse_id", r.warehouseId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateStockIncrementRequestInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIUpdateStockOverwriteRequest struct {
	ctx context.Context
	ApiService ProductAPI
	fsId int64
	shopId *int64
	updateStockInput *[]UpdateStockInput
	bypassUpdateProductStatus *bool
	warehouseId *int64
}

func (r ProductAPIUpdateStockOverwriteRequest) ShopId(shopId int64) ProductAPIUpdateStockOverwriteRequest {
	r.shopId = &shopId
	return r
}

func (r ProductAPIUpdateStockOverwriteRequest) UpdateStockInput(updateStockInput []UpdateStockInput) ProductAPIUpdateStockOverwriteRequest {
	r.updateStockInput = &updateStockInput
	return r
}

func (r ProductAPIUpdateStockOverwriteRequest) BypassUpdateProductStatus(bypassUpdateProductStatus bool) ProductAPIUpdateStockOverwriteRequest {
	r.bypassUpdateProductStatus = &bypassUpdateProductStatus
	return r
}

func (r ProductAPIUpdateStockOverwriteRequest) WarehouseId(warehouseId int64) ProductAPIUpdateStockOverwriteRequest {
	r.warehouseId = &warehouseId
	return r
}

func (r ProductAPIUpdateStockOverwriteRequest) Execute() (*UpdateStockResponse, *http.Response, error) {
	return r.ApiService.UpdateStockOverwriteExecute(r)
}

func (r ProductAPIUpdateStockOverwriteRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*UpdateStockResponse, *http.Response, error) {
	return r.ApiService.UpdateStockOverwriteExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
UpdateStockOverwrite Method for UpdateStockOverwrite

This endpoint used for update product stock. You can update up to 100 products or SKUs in a single request to this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @return ProductAPIUpdateStockOverwriteRequest
*/
func (a *ProductAPIService) UpdateStockOverwrite(ctx context.Context, fsId int64) ProductAPIUpdateStockOverwriteRequest {
	return ProductAPIUpdateStockOverwriteRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
	}
}

// Execute executes the request
//  @return UpdateStockResponse
func (a *ProductAPIService) UpdateStockOverwriteExecute(r ProductAPIUpdateStockOverwriteRequest) (*UpdateStockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateStockResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.UpdateStockOverwrite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/stock/update"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.updateStockInput == nil {
		return localVarReturnValue, nil, reportError("updateStockInput is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.bypassUpdateProductStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bypass_update_product_status", r.bypassUpdateProductStatus, "")
	}
	if r.warehouseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warehouse_id", r.warehouseId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateStockInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return UpdateStockResponse
func (a *ProductAPIService) UpdateStockOverwriteExecuteWithRetry(r ProductAPIUpdateStockOverwriteRequest, maxRetry, maxDelayMs int) (*UpdateStockResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateStockResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.UpdateStockOverwrite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/inventory/v1/fs/{fs_id}/stock/update"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId == nil {
		return localVarReturnValue, nil, reportError("shopId is required and must be specified")
	}
	if r.updateStockInput == nil {
		return localVarReturnValue, nil, reportError("updateStockInput is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "shop_id", r.shopId, "")
	if r.bypassUpdateProductStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bypass_update_product_status", r.bypassUpdateProductStatus, "")
	}
	if r.warehouseId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "warehouse_id", r.warehouseId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateStockInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v BaseErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
