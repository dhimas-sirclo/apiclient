/*
Tokopedia API

Tokopedia API

API version: 1.0
Contact: dev@sirclo.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tokopedia

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FinanceAPI interface {

	/*
	GetSaldoHistory Method for GetSaldoHistory

	This endpoint returns seller saldo history from Shop ID that associated with FS ID. This endpoint has two types of response as json format and files format with .xls extension

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fsId Fulfillment service unique identifier
	@param shopId Shop service unique identifier
	@return FinanceAPIGetSaldoHistoryRequest
	*/
	GetSaldoHistory(ctx context.Context, fsId int64, shopId int64) FinanceAPIGetSaldoHistoryRequest

	// GetSaldoHistoryExecute executes the request
	//  @return GetSaldoHistory200Response
	GetSaldoHistoryExecute(r FinanceAPIGetSaldoHistoryRequest) (*GetSaldoHistory200Response, *http.Response, error)

	// GetSaldoHistoryExecuteWithRetry executes the request with retry
	//  @return GetSaldoHistory200Response
	GetSaldoHistoryExecuteWithRetry(r FinanceAPIGetSaldoHistoryRequest, maxRetry, maxDelayMs int) (*GetSaldoHistory200Response, *http.Response, error)
}

// FinanceAPIService FinanceAPI service
type FinanceAPIService service

type FinanceAPIGetSaldoHistoryRequest struct {
	ctx context.Context
	ApiService FinanceAPI
	fsId int64
	shopId int64
	fromDate *string
	toDate *string
	page *int64
	perPage *int64
	export *int64
}

// UNIX timestamp of date (hour, min, sec) from which the order details are requested. Max Range per request 31 Days
func (r FinanceAPIGetSaldoHistoryRequest) FromDate(fromDate string) FinanceAPIGetSaldoHistoryRequest {
	r.fromDate = &fromDate
	return r
}

// UNIX timestamp of date (hour, min, sec) to which the order details are requested. Max Range per request 31 Days
func (r FinanceAPIGetSaldoHistoryRequest) ToDate(toDate string) FinanceAPIGetSaldoHistoryRequest {
	r.toDate = &toDate
	return r
}

// Determine which page the order list should start. Start from 1. You can get the next page when the previous page has have_next_page value true
func (r FinanceAPIGetSaldoHistoryRequest) Page(page int64) FinanceAPIGetSaldoHistoryRequest {
	r.page = &page
	return r
}

// Determine how many orders will be shown per page. The maximum value is 500
func (r FinanceAPIGetSaldoHistoryRequest) PerPage(perPage int64) FinanceAPIGetSaldoHistoryRequest {
	r.perPage = &perPage
	return r
}

// When the value is 1 then data will be send as files with .xls extension
func (r FinanceAPIGetSaldoHistoryRequest) Export(export int64) FinanceAPIGetSaldoHistoryRequest {
	r.export = &export
	return r
}

func (r FinanceAPIGetSaldoHistoryRequest) Execute() (*GetSaldoHistory200Response, *http.Response, error) {
	return r.ApiService.GetSaldoHistoryExecute(r)
}

func (r FinanceAPIGetSaldoHistoryRequest) ExecuteWithRetry(maxRetry, maxDelayMs int) (*GetSaldoHistory200Response, *http.Response, error) {
	return r.ApiService.GetSaldoHistoryExecuteWithRetry(r, maxRetry, maxDelayMs)
}

/*
GetSaldoHistory Method for GetSaldoHistory

This endpoint returns seller saldo history from Shop ID that associated with FS ID. This endpoint has two types of response as json format and files format with .xls extension

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fsId Fulfillment service unique identifier
 @param shopId Shop service unique identifier
 @return FinanceAPIGetSaldoHistoryRequest
*/
func (a *FinanceAPIService) GetSaldoHistory(ctx context.Context, fsId int64, shopId int64) FinanceAPIGetSaldoHistoryRequest {
	return FinanceAPIGetSaldoHistoryRequest{
		ApiService: a,
		ctx: ctx,
		fsId: fsId,
		shopId: shopId,
	}
}

// Execute executes the request
//  @return GetSaldoHistory200Response
func (a *FinanceAPIService) GetSaldoHistoryExecute(r FinanceAPIGetSaldoHistoryRequest) (*GetSaldoHistory200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSaldoHistory200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FinanceAPIService.GetSaldoHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/fs/{fs_id}/shop/{shop_id}/saldo-history"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromDate == nil {
		return localVarReturnValue, nil, reportError("fromDate is required and must be specified")
	}
	if r.toDate == nil {
		return localVarReturnValue, nil, reportError("toDate is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	if r.export != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "export", r.export, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ExecuteWithRetry executes the request with retry
//  @return GetSaldoHistory200Response
func (a *FinanceAPIService) GetSaldoHistoryExecuteWithRetry(r FinanceAPIGetSaldoHistoryRequest, maxRetry, maxDelayMs int) (*GetSaldoHistory200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSaldoHistory200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FinanceAPIService.GetSaldoHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/fs/{fs_id}/shop/{shop_id}/saldo-history"
	localVarPath = strings.Replace(localVarPath, "{"+"fs_id"+"}", url.PathEscape(parameterValueToString(r.fsId, "fsId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fromDate == nil {
		return localVarReturnValue, nil, reportError("fromDate is required and must be specified")
	}
	if r.toDate == nil {
		return localVarReturnValue, nil, reportError("toDate is required and must be specified")
	}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}
	if r.perPage == nil {
		return localVarReturnValue, nil, reportError("perPage is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "from_date", r.fromDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "to_date", r.toDate, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	if r.export != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "export", r.export, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPIWithRetry(req, maxRetry, maxDelayMs)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
